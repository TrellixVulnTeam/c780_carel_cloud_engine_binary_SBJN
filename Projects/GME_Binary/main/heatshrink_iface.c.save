#include <stdlib.h>
#include <stdio.h>
//#include <unistd.h>
//#include <stdint.h>
//#include <assert.h>
#include <string.h>
//#include <fcntl.h>
//#include <getopt.h>

#include "esp_log.h"
#include "esp_err.h"
//#include "../spiffs_manager.h"


#include "heatshrink_encoder.h"
#include "heatshrink_decoder.h"

#define DEF_WINDOW_SZ2                  9    //11
#define DEF_LOOKAHEAD_SZ2               4
#define DEF_DECODER_INPUT_BUFFER_SIZE   256
#define DEF_BUFFER_SIZE                 (1 * 1024)



//#include <err.h>
#define HEATSHRINK_ERR(x) printf("%s %s", TAG, x)


static const char *TAG = "HEATSHRINK";

/*
uint8_t SAMPLE[] = {'p','i','p','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g',
					'h','i','f','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'p','i','p','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'p','i','b','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'p','i','p','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'p','i','p','p','o','n','l','u','1','o','m','y','j','s','o','n',
					'p','i','p','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'p','i','p','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'p','i','p','p','o','p','l','u','A','o','m','F','F','s','o','n',
					'p','i','p','p','o','p','l','u','t','o','m','y','j','2','o','n',
					'p','i','p','p','o','p','l','u','t','o','m','y','j','3','o','n',
					'p','i','p','p','o','p','l','u','t','h','m','y','j','s','o','n',
					'p','i','p','p','=','p','l','u','t','o','m','y','j','4','o','n',
					'p','i','e','p','o','p','l','u','t','o','m','y','j','s','o','n',
					'p','i','p','p','e','p','l','u','t','o','m','y','j','s','o','n'
		           } ;
*/

/*
 * We have to open binary files with the O_BINARY flag on Windows. Most other
 * platforms don't differentiate between binary and non-binary files.
 */
#ifndef O_BINARY
#define O_BINARY 0
#endif

//todo CHIEBAO
uint8_t INBUFF[1024] = {0};
uint8_t OUTBUFF[1024] = {0};


static const int version_major = HEATSHRINK_VERSION_MAJOR;
static const int version_minor = HEATSHRINK_VERSION_MINOR;
static const int version_patch = HEATSHRINK_VERSION_PATCH;
static const char author[] = HEATSHRINK_AUTHOR;
static const char url[] = HEATSHRINK_URL;

typedef enum { IO_READ, IO_WRITE, } IO_mode;
typedef enum { OP_ENC, OP_DEC, } Operation;

typedef struct {
    int fd;                     /* file descriptor */
    IO_mode mode;
    size_t fill;                /* fill index */
    size_t read;                /* read index */
    size_t size;
    size_t total;
    uint8_t buf[];
} io_handle;

typedef struct {
    uint8_t window_sz2;
    uint8_t lookahead_sz2;
    size_t decoder_input_buffer_size;
    size_t buffer_size;
    uint8_t verbose;
    Operation cmd;
    char *in_fname;
    char *out_fname;
    io_handle *in;
    io_handle *out;
} config;


static void die(char *msg) {
	 ESP_LOGI(TAG,"@ DIE %s\n", msg);
}



/* Drop the oldest SIZE bytes from the buffer. Returns <0 on error. */
static int handle_drop(io_handle *io, size_t size) {
    ESP_LOGI(TAG,"@ drop %zd\n", size);
    if (io->read + size <= io->fill) {
        io->read += size;
    } else {
        return -1;
    }
    if (io->read == io->fill) {
        io->read = 0;
        io->fill = 0;
    }
    return 0;
}


/*
//             handle_sink(out,              poll_sz,        out_buf) < 0)  //
static ssize_t handle_sink(io_handle *io, size_t size, uint8_t *input) {
    LOG("@ sink %zd\n", size);

    if (size > io->size)
    {
    	return -1;
    }

    if (io->mode != IO_WRITE)
    {
    	return -1;
    }

    if (io->fill + size > io->size)
    {
        ssize_t written = write(io->fd, io->buf, io->fill);

        LOG("@ flushing %zd, wrote %zd\n", io->fill, written);

        io->total += written;

        if (written == -1)
        {
        	HEATSHRINK_ERR(1, "write");
        }

        memmove(io->buf, &io->buf[written], io->fill - written);

        io->fill -= written;
    }

    memcpy(&io->buf[io->fill], input, size);

    io->fill += size;

    return size;
}
*/


static int encoder_sink_read(config *cfg, heatshrink_encoder *hse, uint8_t *data, size_t data_sz) {

	size_t out_sz = 1024;

    uint8_t out_buf[out_sz];

    memset(out_buf, 0, out_sz);

    size_t sink_sz = 0;
    size_t poll_sz = 0;
    HSE_sink_res sres;
    HSE_poll_res pres;
    HSE_finish_res fres;
    io_handle *out = out_buf;

    size_t sunk = 0;

    do {

        if (data_sz > 0)
        {
            sres = heatshrink_encoder_sink(hse, &data[sunk], data_sz - sunk, &sink_sz);

            if (sres < 0)
            {
            	die("sink");
            }
            sunk += sink_sz;
        }
        
        do {
            pres = heatshrink_encoder_poll(hse, out_buf, out_sz, &poll_sz);

            if (pres < 0)
            {
            	die("poll");
            }

            //
            //if (handle_sink(out, poll_sz, out_buf) < 0)
            //{
            //	die("handle_sink");
            //}

        } while (pres == HSER_POLL_MORE);
        
        if (poll_sz == 0) // && data_sz == 0)
        {
            fres = heatshrink_encoder_finish(hse);

            if (fres < 0)
            {
            	die("finish");
            }

            if (fres == HSER_FINISH_DONE)
            {
            	return 1;
            }
        }
    } while (sunk < data_sz);
    return 0;
}



//static int encode(config *cfg)
//{
//
//	uint8_t window_sz2 = cfg->window_sz2;
//    size_t window_sz = 1 << window_sz2;
//
//    heatshrink_encoder *hse = heatshrink_encoder_alloc(window_sz2, cfg->lookahead_sz2);
//
//    if (hse == NULL)
//    {
//    	die("failed to init encoder: bad settings");
//    }
//
//
//    ssize_t read_sz = 0;
//
//    //io_handle *in = cfg->in;
//
//    uint8_t *input = SAMPLE;
//
//    read_sz = sizeof(SAMPLE);
//
//
//    /* Process input until end of stream */
//    while (1) {
//
//        /* Pass read to encoder and check if input is fully processed. */
//        if (encoder_sink_read(cfg, hse, input, read_sz))
//        	break;
//
////        if (handle_drop(SAMPLE, read_sz) < 0)
////        {
////
////        	die("drop");
////
////        }
//    };
//
//    if (read_sz == -1) { HEATSHRINK_ERR("read"); }
//
//    heatshrink_encoder_free(hse);
////    close_and_report(cfg);
//    return 0;

//}



static heatshrink_encoder hse;
static heatshrink_decoder hsd;


static void compress_and_expand_and_check(uint8_t *input, uint32_t input_size)
{
	uint8_t mybuff[240];


    heatshrink_encoder_reset(&hse);
    heatshrink_decoder_reset(&hsd);

    size_t comp_sz = input_size + (input_size/2) + 4;
    size_t decomp_sz = input_size + (input_size/2) + 4;

    uint8_t *comp = malloc(comp_sz);
    uint8_t *decomp = malloc(decomp_sz);

    if (comp == NULL) printf("malloc fail");

    if (decomp == NULL) printf("malloc fail");

    memset(comp, 0, comp_sz);
    memset(decomp, 0, decomp_sz);

    size_t count = 0;


    /*** COMPRESS ***/

    uint32_t sunk = 0;
    uint32_t polled = 0;

    while (sunk < input_size) {
        heatshrink_encoder_sink(&hse, &input[sunk], input_size - sunk, &count);

        sunk += count;

        if (sunk == input_size) {
            heatshrink_encoder_finish(&hse);
        }

        HSE_poll_res pres;
        do {                    /* "turn the crank" */
            pres = heatshrink_encoder_poll(&hse, &comp[polled], comp_sz - polled, &count);

            polled += count;

        } while (pres == HSER_POLL_MORE);



        if (polled >= comp_sz)
        	printf("compression should never expand that much");

        if (sunk == input_size) {
            heatshrink_encoder_finish(&hse);
        }
    }



    for(uint8_t i = 0; i<240; i++)
    	mybuff[i] =  (uint8_t)comp[i];

    if(mybuff[0] == 0x55)
    {
    	mybuff[1] = 1;

    }

    uint32_t compressed_size = polled;
    sunk = 0;
    polled = 0;


        /*** DECOMPRESSING ***/

    while (sunk < compressed_size) {
        heatshrink_decoder_sink(&hsd, &comp[sunk], compressed_size - sunk, &count);

        sunk += count;

        if (sunk == compressed_size) {
            heatshrink_decoder_finish(&hsd);
        }

        HSD_poll_res pres;
        do {
            pres = heatshrink_decoder_poll(&hsd, &decomp[polled],
                decomp_sz - polled, &count);

            polled += count;

        } while (pres == HSDR_POLL_MORE);



        if (sunk == compressed_size)
        {
            HSD_finish_res fres = heatshrink_decoder_finish(&hsd);

        }

        if (polled > input_size)
        {
        	printf("Decompressed data is larger than original input");
        }
    }

    if (polled != input_size) {
    	printf("Decompressed length does not match original input length");
    }

    free(comp);
    free(decomp);
}



void test(void)
{

 uint8_t buff_in[512];

 //config cfg;

 // usiamo la configurazione statica con i valori di default
 //
 //cfg.window_sz2 = DEF_WINDOW_SZ2;
 //cfg.lookahead_sz2 = DEF_LOOKAHEAD_SZ2;
 //cfg.buffer_size = DEF_BUFFER_SIZE;
 //cfg.decoder_input_buffer_size = DEF_DECODER_INPUT_BUFFER_SIZE;
 //cfg.cmd = OP_ENC;
 //cfg.verbose = 0;
 //cfg.in_fname = NULL;
 //cfg.out_fname = NULL;


 //encode(&cfg);

 //ARS DEBUG
 /*
 memset(buff_in, 0x00, 512);

 long size = filesize("/spiffs/model_1.bin");

 FILE* fp = fopen("/spiffs/model_1.bin", "r");

 fread(buff_in, size, 1, fp);

 fclose(fp);

 compress_and_expand_and_check(buff_in, size);
*/

}
